# *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*
# *  CLASS input parameter file  *
# *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~*

# This example of input file, intended for CLASS beginners, lists all
# possibilities with detailed comments. You can use a more concise version, in
# which only the arguments in which you are interested would appear. Only lines
# containing an equal sign not preceded by a sharp sign "#" are considered by
# the code, any other line is considered as a comment.
#
# The normal syntax is:      parameter = value(s)
# where white spaces do not matter (they are removed automatically by the
# parser unless they are part of the parameter name).
# However,                   'parameter' = value(s)
# and                        "parameter" = value(s)
# are also accepted by the parser since v2.8.0
#
# Input files must have an extension ".ini".



# -------------------------
# ----> General parameters:
# -------------------------

# 1) List of output spectra requested:
#       - 'tCl' for temperature Cls,
#       - 'pCl' for polarization Cls,
#       - 'lCl' for CMB lensing potential Cls,
#       - 'nCl' (or 'dCl') for density number count Cls,
#       - 'sCl' for galaxy lensing potential Cls,
#       - 'mPk' for total matter power spectrum P(k) infered from gravitational
#         potential,
#       - 'dTk' (or 'mTk') for density transfer functions for each species,
#       - 'vTk' for velocity transfer function for each species
#       - 'sd' for spectral distortions
#    Warning: both l0.6732Cl and sCl compute the C_ls of the lensing potential,
#    C_l^phi-phi. If you are used to other codes, you may want to deal instead
#    with the deflection Cls or the shear/convergence Cls. The relations
#    between them are trivial:
#        --> deflection d: Cl^dd = l(l+1) C_l^phiphi
#        --> convergence kappa and shear gamma: the share the same harmonic
#            power spectrum: Cl^gamma-gamma = 1/4 * [(l+2)!/(l-2)!] C_l^phi-phi
#    By defaut, the code will try to compute the following cross-correlation
#    Cls (if available): temperature-polarisation, temperature-CMB lensing,
#    polarization-CMB lensing, CMB lensing-density, and density-lensing. Other
#    cross-correlations are not computed because they would slow down the
#    code considerably.
#
#    Can be left blank if you do not want to evolve cosmological perturbations
#    at all. (default: set to blank, no perturbation calculation)
output = tCl,pCl,lCl,mPk
#output = tCl,pCl,lCl
#output = mPk,mTk
#output = Sd
lensing = yes

# 1.a) If you included 'tCl' in the list, you can take into account only some
#      of the terms contributing to the temperature spectrum:
#         - intrinsic temperature corrected by Sachs-Wolfe ('tsw' or 'TSW'),
#         - early integrated Sachs-Wolfe ('eisw' or 'EISW'),
#         - late integrated Sachs-Wolfe ('lisw' or 'LISW'),
#         - Doppler ('dop' or 'Dop'),
#         - polarisation contribution ('pol' or 'Pol').
#      Put below the list of terms to be included (defaut: if this field is not
#      passed, all terms will be included)
#temperature_contributions = tsw, eisw, lisw, dop, pol

# 1.a.1) If one of 'eisw' or 'lisw' is turned off, the code will read
#        'early/late isw redshift', the split value of redshift z at which the
#        isw is considered as late or early (if this field is absent or left
#        blank, by default, 'early/late isw redshift' is set to 50)
#early_late_isw_redshift =

# 1.b) If you included 'nCl' (or 'dCl') in the list, you can take into account
#      only some of the terms contributing to the obsevable number count
#      fluctuation spectrum:
#          - matter density ('density'),
#          - redshift-space and Doppler distortions ('rsd'),
#          - lensing ('lensing'),
#          - or gravitational potential terms ('gr').
#      Put below the list of terms to be included (defaut: if this field is not
#      passed, only 'dens' will be included)
#number_count_contributions = density, rsd, lensing, gr

# 1.c) If you included 'dTk' (or 'mTk') in the list, the code will give you by
#      default the transfer function of the scale-invariant Bardeen potentials
#      (for whatever gauge you are using). If you need the transfer function of
#      additional metric fluctuations, specific to the gauge you are using, set
#      the following flag to 'yes' (default: set to 'no')
#extra_metric_transfer_functions = yes


# 2) If you want to consider perturbed recombination, enter a word
#    containing the letter 'y' or 'Y'. CLASS will then compute the
#    perturbation in the ionization fraction x_e and the baryon
#    temperature, as in 0707.2727. The initial conformal time will be
#    small, therefore you should use the default integrator ndf15
#    (i.e. do not set 'evolver' to 0, otherwise the code will be
#    slower).  (default: no, neglect perturbed recombination)
#perturbed_recombination = yes

# 3) List of modes:
#         - 's' for scalars,
#         - 'v' for vectors,
#         - 't' for tensors).
#      More than one letter allowed, can be attached or separated by arbitrary
#      characters; letters can be small or capital. (default: set to 's')
modes = s
#modes = s,t

# 3.a) List of initial conditions for scalars:
#           - 'ad' for adiabatic,
#           - 'bi' for baryon isocurvature,
#           - 'cdi' for CDM isocurvature,
#           - 'nid' for neutrino density isocurvature,
#           - 'niv' for neutrino velocity isocurvature.
#        More than one of these allowed, can be attached or separated by arbitrary
#        characters; letters can be small or capital. (default: set to 'ad')
ic = ad
#ic = ad&bi&nid

# 3.b) Which perturbations should be included in tensor calculations?
#           - write 'exact' to include photons, ultra-relativistic species 'ur'
#             and all non-cold dark matter species 'ncdm';
#           - write 'massless' to approximate 'ncdm' as extra relativistic species
#             (good approximation if ncdm is still relativistic at the time of
#             recombination);
#           - write 'photons' to include only photons
#        (default: set to 'massless')
tensor_method =


# 4) Gauge
# 4.a) Gauge in which calculations are performed:
#         - 'sync' or 'synchronous' or 'Synchronous' for synchronous,
#         - 'new' or 'newtonian' or 'Newtonian' for Newtonian/longitudinal gauge
#      (default: set to synchronous)
gauge = synchronous

# 4.b) Do you want to output the N-body gauge quantities as well?
#      If you included 'dTk' or 'vTk' in the list of outputs, you may transform
#      your transfer functions into the Nbody gauge by setting the following
#      flag to 'yes'. This will also include the transfer function for the
#      metric perturbations H_T' (exact) and gamma (approximate) in the Nbody gauge.
#      See e.g. 1505.04756, and equations (A.2) and (A.5) in 1811.00904
#      for more precise definitions. These calculations are more stable with
#      'gauge=synchronous' (default). To compute H_T' and gamma
#      without converting the output to the Nbody gauge,
#      please use the flag 'extra metric transfer functions' instead.
#      Can be set to a	nything starting with 'y' or 'n'.
#      (default: set to 'no')
#nbody_gauge_transfer_functions = yes

# 5) Hubble parameter : either 'H0' in km/s/Mpc or 'h' or '100*theta_s', where
#    the latter is the peak scale parameter defined exactly as 100(ds_dec/da_dec)
#    with a decoupling time given by maximum of visibility function (quite different
#    from theta_MC of CosmoMC and slightly different from theta_* of CAMB)
#    (default: 'h' set to 0.67810 such that 100*theta_s = 1.041783 like in Planck 2018)
h = 0.6736
#H0 = 67.360
#100*theta_s = 1.041783


# 6) Primordial Helium fraction 'YHe', e.g. 0.25; if set to 'BBN' or 'bbn',
#    will be inferred from Big Bang Nucleosynthesis (default: set to 'BBN')
YHe = BBN


# 7) 'recombination' algorithm set to 'RECFAST' or 'HyRec'. 'HyRec' points at HyRec 2020. Its compute time is negligible compared to other CLASS modules. 'RECFAST' points at RecFastCLASS, an enhanced version of RecFast 1.5 with better integration shceme and less discontinuities. Recfast is still slightly faster than HyRec but less accurate. HyRec is better for most purposes. RecFast can still be useful for studying some particular modifications of standard recombination. Both schemes use the CLASS ODE integrators. (Default: HyRec')
recombination = HyRec

# 7.a) If recombination algorithm is set to 'RECFAST'
#      the photo-ionization coefficients beta(T) for normal Recfast depend on Tmat
#      This is an approximation (see e.g. arxiv:1605.03928 page 10, arxiv:1503.04827 page 2, right column)
#      With 'recfast_photoion_dependence' the photo-ionization coefficient beta(T) is set to depend on
#          - 'Tmat' uses beta(Tmat) depending on matter temperature
#                   (like in original RECFAST and in CLASS v2.x)
#          - 'Trad' uses beta(Trad) depending on radiation temperature
#                   (while this option is theoretically more motivated, the option 'Tmat' leads to
#                    results which agree better with HyRec and CosmoRec. This is probably due to the
#                    fudge factor for the Peebles coefficient being optimized for a Tmat dependence)
#      (default: set to 'Tmat')
recfast_photoion_dependence =


# 8) Parametrization of reionization: 'reio_parametrization' must be one of
#       - 'reio_none' (no reionization),
#       - 'reio_camb' (like CAMB: one tanh() step for hydrogen reionization one
#         for second helium reionization),
#       - 'reio_bins_tanh' (binned history x_e(z) with tanh()  interpolation
#         between input values),
#       - 'reio_half_tanh' (like 'reio_camb' excepted that we match the
#         function xe(z) from recombination with only half a tanh(z-z_reio)),
#       - 'reio_many_tanh' (arbitrary number of tanh-like steps with specified
#         ending values, a scheme usually more useful than 'reio_bins_tanh'),
#       - 'reio_inter' (linear interpolation between discrete values of xe(z)).
#    (default: set to 'reio_camb')
reio_parametrization = reio_camb

# 8.a) If 'reio_parametrization' set to 'reio_camb' or 'reio_half_tanh':
#      enter one of 'z_reio' or 'tau_reio' (default: 'z_reio' set to 7.6711 to
#      get tau_reio of 0.054308), plus 'reionization_exponent',
#      'reionization_width', 'helium_fullreio_redshift',
#      'helium_fullreio_width'. (default: set to 1.5, 0.5, 3.5, 0.5)
z_reio = 7.6711
#tau_reio = 0.05430842
reionization_exponent = 1.5
reionization_width = 0.5
helium_fullreio_redshift = 3.5
helium_fullreio_width = 0.5

# 8.b) If 'reio_parametrization' set to 'reio_bins_tanh':
#      enter number of bins and list of z_i and xe_i defining the free electron
#      density at the center of each bin. Also enter a dimensionless paramater
#      regulating the sharpness of the tanh() steps, independently of the bin
#      width; recommended sharpness is 0.3, smaller values will make steps too
#      sharp, larger values will make the step very progressive but with
#      discontinuity of x_e(z) derivative around z_i values. (default: set to
#      0, blank, blank, 0.3)
binned_reio_num = 3
binned_reio_z = 8,12,16
binned_reio_xe = 0.8,0.2,0.1
binned_reio_step_sharpness = 0.3

# 8.c) If 'reio_parametrization' set to 'reio_many_tanh':
#      enter number of jumps, list of jump redhsifts z_i (central value of each
#      tanh()), list of free electron density x_i after each jump, and common
#      width of all jumps. If you want to end up with all hydrogen reionized
#      but neglecting helium reionization, the first value of x_i in the list
#      should be 1. For each x_i you can also pass the flags -1 or -2. They
#      mean:
#         - -1: after hydrogen + first helium recombination (so the code will
#               substitute a value bigger than one based on Y_He);
#         - -2: after hydrogen + second helium recombination (the code will
#               substitute an even bigger value based on Y_He).
#      You can get results close to reio_camb by setting these parameters to
#      the value showed below (and adapting the second many_tanh_z to the usual
#      z_reio). (default: not set)
many_tanh_num = 2
many_tanh_z = 3.5,11.3
many_tanh_xe = -2,-1
many_tanh_width = 0.5

# 8.d) If 'reio_parametrization' set to 'reio_inter': enter the number of
#      points, the list of redshifts z_i, and the list of free electron
#      fraction values x_i. The code will do linear interpolation between them.
#      The first z_i should always be 0. Like above, for each x_i, you can also
#      pass the flags -1 or -2. They mean: for -1, after the hydrogen and the
#      first helium recombination (so the code will substitute a value bigger
#      than one based on Y_He); for -2, after the hydrogen and the second
#      helium recombination (the code will substitute an even bigger value
#      based on Y_He). The last value of x_i should always be zero, the code
#      will substitute it with the value that one would get in absence of
#      reionization, as computed by the recombination code. (default: not set)
reio_inter_num = 8
reio_inter_z =   0,  3,  4,   8,   9,  10,  11, 12
reio_inter_xe = -2, -2, -1,  -1, 0.9, 0.5, 0.1,  0


# -------------------------
# ----> Species parameters:
# -------------------------

# 1) Photon density: either 'T_cmb' in K or 'Omega_g' or 'omega_g' (default:
#    'T_cmb' set to 2.7255)
T_cmb = 2.7255
#Omega_g =
#omega_g =


# 2) Baryon density: either 'Omega_b' or 'omega_b' (default: 'omega_b' set to
#    0.02238280)
omega_b = 0.02237
#Omega_b = 0.0493017


# 3) Ultra-relativistic species / massless neutrino density: either
# 'N_ur' or 'Omega_ur' or 'omega_ur' (default: 'N_ur' set to 3.044;
# see 2008.01074 and 2012.02726. This value is more accurate than the
# previous default value of 3.046) (note: instead of 'N_ur' you can
# pass equivalently 'N_eff', although this syntax is deprecated) (one
# more remark: if you have respectively 1,2,3 massive neutrinos, if
# you stick to the default value T_ncdm equal to 0.71611, designed to
# give m/omega of 93.14 eV, and if you want to use N_ur to get N_eff
# equal to 3.044 in the early universe, then you should pass here
# respectively 2.0308,1.0176,0.00441)
N_ur = 3.044
#Omega_ur =
#omega_ur =


# 4) Density of cdm (cold dark matter): 'Omega_cdm' or 'omega_cdm' (default:
#    'omega_cdm' set to 0.1201075)
omega_cdm = 0.12000
#Omega_cdm = 0.26590612


# 5) ncdm sector (i.e. any non-cold dark matter relics, including massive
#    neutrinos, warm dark matter, etc.):
# 5.a) 'N_ncdm' is the number of distinct species (default: set to 0)
N_ncdm =


# 5.d) 'Omega_ncdm' or 'omega_ncdm' or 'm_ncdm' in eV (default: all set to
#      zero); with only one of these inputs, CLASS computes the correct value
#      of the mass; if both (Omega_ncdm, m_ncdm) or (omega_ncdm, m_ncdm) are
#      passed, CLASS will renormalise the psd in order to fulfill both
#      conditions. Passing zero in the list of m_ncdm's or Omeg_ncdm's means
#      that for this component, this coefficient is not imposed, and its value
#      is inferred from the other one.
m_ncdm = 0.06
#m_ncdm = 0.04, 0.04, 0.04
#Omega_ncdm =
#omega_ncdm =



# 6) Curvature: 'Omega_k' (default: 'Omega_k' set to 0)
Omega_k = 0.0



# 8) Dark energy contributions.
#    At least one out of three conditions must be satisfied:
#          - 'Omega_Lambda' unspecified.
#          - 'Omega_fld' unspecified.
#          - 'Omega_scf' set to a negative value. [Will be refered to as
#             unspecified in the following text.]
#      The code will then use the first unspecified component to satisfy the
#      closure equation (sum_i Omega_i) equals (1 + Omega_k)
#      (default: 'Omega_fld' and 'Omega_scf' set to 0 and 'Omega_Lambda'
#      inferred by code)
Omega_fld = 0
Omega_scf = -0.6813
Omega_Lambda = 0

# Omega_fld & Omega_fld  = 0 & Omega_scf =-anything to make it the only unspecified parameter


# 8.b) If Omega scalar field is different from 0


# 8.b.1) Choose your scalar field potetial between two different models
#         - 'expexp' for V(\phi)=scf_V_alpha*\exp(-\alpha\phi)+scf_V_beta*\exp(-\beta\phi)
#           (The double exponential),
#         - 'expeta' for V(\phi) = V_0(\eta+\exp(-\alpha\phi))^(-\beta)
scf_potential = EXPEXP

# 8.b.1.1) EXEPEXP: Scalar field (scf) potential parameters and initial conditions
#        (scf_parameters = [alpha, beta, V_alpha, V_beta, phi, phi_prime]).
#        V(\phi) = (scf_V_1*\exp(-\scf_alpha*\phi)+scf_V_2*\exp(-\scf_beta*\phi)).

#	 If 'attractor_ic_scf' is set to 'no', the last two entries are assumed to be the
#        initial values of phi in units of the reduced planck mass m_Pl and the conformal
#        time derivative of phi in units of [m_Pl/Mpc].
#        (Note however that CLASS determines the initial scale factor dynamically
#        and the results might not be as expected in some models.)
#
#scf_parameters = \alpha, \beta, V_\alpha (V_1), V_\beta (V_2), \phi_i, \phi'_i
scf_parameters = 6.324555320336759, 0.01, 3.57895e-9, 1.04911e-7, -4.58304, 7.45603e-14
#scf_parameters = 6.324555320336759, 0.01, 3.57895e-9, 1.04911e-7 (0.5e-7 shooting from below), -4.58304, 7.45603e-14
# 8.b.1.2) EXEPETA: Scalar field (scf) potential parameters and initial conditions
#        (scf_parameters = [alpha, beta, V_0, eta, phi,phi_prime])
# 	 V(\phi) = scf_V_1(\scf_V_2+\exp(-\scf_alpha*\phi))^(-\scf_beta).
#
#scf_parameters = 3.16227766016838, -2, 5.90184e-10, 12.1484, -4.86802, 7.45603e-14

# 8.b.2) Scalar field (scf) initial conditions from attractor solution (assuming
#        pure exponential potential). (default: yes)
attractor_ic_scf = no


# 8.b.3) Scalar field (scf) shooting parameter: If Omega_scf is set (can only be negative),
#        the following index (0,1,2,...) in the list scf_parameters will be used for shooting:
#        (See also the section about shooting in input.c)
#        Basically parameter number scf_tuning_index will be adjusted until
#        the correct Omega_scf is found to suffice the budget equation
scf_tuning_index = 3

#	 index=0 -> alpha
#	 index=1 -> beta
#	 index=2 -> V_alpha
#	 index=3 -> V_beta
#	 index=4 -> phi_i
#	 index=3 -> phidot_i

#test

# 8.b.4) Scalar field (scf) shooting parameter, for tuning Omega_scf, and alpha shooting
#	 parameter for tuning the fraction of EDE. With this, you can overwrite some parameter
#        of 8.b.1) depending on the index defined in 8.b.3)
scf_shooting_parameter =
scf_alpha_shooting =
do_shooting = yes
#        switch for Omega0_scf shooting
f_ede_scf =
#        target of the EDE fraction

# ----------------------------

# 1) Primordial spectrum type
#       - 'analytic_Pk' for an analytic smooth function with amplitude, tilt,
#         running, etc.; analytic spectra with feature can also be added as
#         a new type;
#       - 'inflation_V' for a numerical computation of the inflationary
#         primordial spectrum, through a full integration of the perturbation
#         equations, given a parametrization of the potential V(phi) in the
#         observable window, like in astro-ph/0703625;
#       - 'inflation_H' for the same, but given a parametrization of the
#         potential H(phi) in the observable window, like in
#         astro-ph/0710.1630;
#       - 'inflation_V_end' for the same, but given a parametrization of the
#         potential V(phi) in the whole region between the observable part and
#         the end of inflation;
#       - 'two scales' allows to specify two amplitudes instead of one
#         amplitude and one tilt, like in the isocurvature mode analysis of the
#         Planck inflation paper (works also for adiabatic mode only; see
#         details below, item 2.c);
#       - 'external_Pk' allows for the primordial spectrum to be computed
#         externally by some piece of code, or to be read from a table, see
#         2.d).
#    (default: set to 'analytic_Pk')
Pk_ini_type = analytic_Pk

# 1.a) Pivot scale in Mpc-1 (default: set to 0.05)
k_pivot = 0.05

# 1.b) For type 'analytic_Pk':
# 1.b.1) For scalar perturbations
#        curvature power spectrum value at pivot scale ('A_s' or
#        'ln10^{10}A_s') OR 'sigma8' (found by iterations using a shooting
#        method). (default: set 'A_s' to 2.100549e-09)
A_s = 2.101e-09
#ln10^{10}A_s = 3.04478383
# sigma8 = 0.824398

# 1.b.1.1) Adiabatic perturbations:
#          tilt at the same scale 'n_s', and tilt running 'alpha_s'
#          (default: set 'n_s' to 0.9660499, 'alpha_s' to 0)
n_s = 0.9649
alpha_s = 0.

# 1.b.1.2) Isocurvature/entropy perturbations:
#          for each mode xx ('xx' being one of 'bi', 'cdi', 'nid', 'niv',
#          corresponding to baryon, cdm, neutrino density and neutrino velocity
#          entropy perturbations), enter the entropy-to-curvature ratio f_xx,
#          tilt n_xx and running alpha_xx, all defined at the pivot scale; e.g.
#          f_cdi of 0.5 means S_cdi/R equal to one half and (S_cdi/R)^2 to 0.25
#          (default: set each 'f_xx' to 1, 'n_xx' to 1, 'alpha_xx' to 0)
f_bi = 1.
n_bi = 1.5
f_cdi=1.
f_nid=1.
n_nid=2.
alpha_nid= 0.01
# etc.

# 1.b.1.3) Cross-correlation between different adiabatic/entropy mode:
#          for each pair (xx, yy) where 'xx' and 'yy' are one of 'ad', 'bi',
#          'cdi', 'nid', 'niv', enter the correlation c_xx_yy (parameter between
#          -1 and 1, standing for cosDelta, the cosine of the cross-correlation
#          angle), the tilt n_xx_yy of the function cosDelta(k), and its running
#          alpha_xx_yy, all defined at the pivot scale. So, for a pair of fully
#          correlated (resp. anti-correlated) modes, one should set (c_xx_yy,
#          n_xx_yy, alpha_xx_yy) to (1,0,0) (resp. (-1,0,0) (default: set each
#          'c_xx_yy' to 0, 'n_xx_yy' to 0, 'alpha_xx_yy' to 0)
c_ad_bi = 0.5
#n_ad_bi = 0.1
c_ad_cdi = -1.
c_bi_nid = 1.
#n_bi_nid = -0.2
#alpha_bi_nid = 0.002
# etc.

# 1.b.2) For tensor perturbations (if any):
#        tensor-to-scalar power spectrum ratio, tilt,
#        running at the pivot scale; if 'n_t' and/or 'alpha_t' is set to 'scc'
#        or 'SCC' isntead of a numerical value, it will be inferred from the
#        self-consistency condition of single field slow-roll inflation: for
#        n_t, -r/8*(2-r/8-n_s); for alpha_t, r/8(r/8+n_s-1) (default: set 'r'
#        to 1, 'n_t' to 'scc', 'alpha_t' to 'scc')
r = 1.
n_t = scc
alpha_t = scc

# 1.c) For type 'inflation_V'
# 1.c.1) Type of potential: 'polynomial' for a Taylor expansion of the
#        potential around phi_pivot. Other shapes can easily be defined in
#        primordial module.
potential = polynomial

# 1.c.2) For 'inflation_V' and 'polynomial': enter either the coefficients
#        'V_0', 'V_1', 'V_2', 'V_3', 'V_4' of the Taylor expansion (in units of
#        Planck mass to appropriate power), or their ratios 'R_0', 'R_1',
#        'R_2', 'R_3', 'R_4' corresponding to (128pi/3)*V_0^3/V_1^2,
#        V_1^2/V_0^2, V_2/V_0, V_1*V_3/V_0, V_1^2*V_4/V_0^3, or the
#        potential-slow-roll parameters 'PSR_0', 'PSR_1', 'PSR_2', 'PSR_3',
#        'PSR_4', equal respectively to R_0, epsilon_V=R_1/(16pi),
#        eta_V=R_2/(8pi), ksi_V=R_3/(8pi)^2, omega_V=R_4/(8pi)^3 (default:
#        'V_0' set to 1.25e-13, 'V_1' to 1.12e-14, 'V_2' to 6.95e-14, 'V_3'
#        and 'V_4' to zero).
V_0=1.e-13
V_1=-1.e-14
V_2=7.e-14
V_3=
V_4=
#R_0=2.18e-9
#R_1=0.1
#R_2=0.01
#R_3=
#R_4=
#PSR_0 = 2.18e-9
#PSR_1 = 0.001989
#PSR_2 = 0.0003979
#PSR_3 =
#PSR_4 =

# 1.d) For 'inflation_H':
#      enter either the coefficients 'H_0', 'H_1', 'H_2', 'H_3', 'H_4' of the
#      Taylor expansion (in units of Planck mass to appropriate power), or the
#      Hubble-slow-roll parameters 'HSR_0', 'HSR_1', 'HSR_2', 'HSR_3', 'HSR_4'
H_0=1.e-13
H_1=-1.e-14
H_2=7.e-14
H_3=
H_4=
#HSR_0 = 2.18e-9
#HSR_1 = 0.001989
#HSR_2 = 0.0003979
#HSR_3 =
#HSR_4 =

# 1.e) For type 'inflation_V_end':
# 1.e.1) Value of the field at the minimum of the potential after inflation, or
#        at a value in which you want to impose the end of inflation, in
#        hybrid-like models. By convention, the code expects inflation to take
#        place for values smaller than this value, with phi increasing with
#        time (using a reflection symmetry, it is always possible to be in that
#        case) (default: 'phi_end' set to 0)
phi_end =

# 1.e.2) Shape of the potential. Refers to functions pre-coded in the primordail
#        module, so far 'polynomial' and 'higgs_inflation'. (default:
#        'full_potential' set to 0)
full_potential = polynomial

# 1.e.3) Parameters of the potential. The meaning of each parameter is
#        explained in the function primrodial_inflation_potential() in
#        source/primordial.c
Vparam0 =
Vparam1 =
Vparam2 =
Vparam3 =
Vparam4 =

# 1.e.4) How much the scale factor a or the product (aH) increases between
#        Hubble crossing for the pivot scale (during inflation) and the end of
#        inflation. You can pass either: 'N_star' (standing for
#        log(a_end/a_pivot)) set to a number; or 'ln_aH_ratio' (standing for
#        log(aH_end/aH_pivot)) set to a number; (default: 'N_star' set to 60)
#ln_aH_ratio = 50
#N_star = 55

# 1.e.5) Should the inflation module do its nomral job of numerical integration
#        ('numerical') or use analytical slow-roll formulas to infer the
#        primordial spectrum from the potential ('analytical')? (default:
#        'inflation_behavior' set to 'numerical')
#inflation_behavior = numerical

# 1.f) For type 'two_scales' (currently this option works only for scalar modes,
#      and either for pure adiabatic modes or adiabatic + one type of
#      isocurvature):
# 1.f.1) Two wavenumbers 'k1' and 'k2' in 1/Mpc, at which primordial amplitude
#        parameters will be given. The value of 'k_pivot' will not be used in
#        input but quantities at k_pivot will still be calculated and stored in
#        the primordial structure (no default value: compulsory input if
#        'P_k_ini type' has been set to 'two_scales')
k1=0.002
k2=0.1

# 1.f.2) Two amplitudes 'P_{RR}^1', 'P_{RR}^2' for the adiabatic primordial
#        spectrum (no default value: compulsory input if 'P_k_ini type' has been
#        set to 'two_scales')
P_{RR}^1 = 2.3e-9
P_{RR}^2 = 2.3e-9

# 1.f.3) If one isocurvature mode has been turned on ('ic' set e.g. to 'ad,cdi'
#        or 'ad,nid', etc.), enter values of the isocurvature amplitude
#        'P_{II}^1', 'P_{II}^2', and cross-correlation amplitude 'P_{RI}^1',
#        '|P_{RI}^2|' (see Planck paper on inflation for details on
#        definitions)
P_{II}^1 = 1.e-11
P_{II}^2 = 1.e-11
P_{RI}^1 = -1.e-13
|P_{RI}^2| = 1.e-13

# 1.f.4) Set 'special iso' to 'axion' or 'curvaton' for two particular cases:
#        'axion' means uncorrelated, n_ad equal to n_iso, 'curvaton' means fully
#        anti-correlated with f_iso<0 (in the conventions of the Planck
#        inflation paper this would be called fully correlated), n_iso equal
#        to one; in these two cases, the last three of the four paramneters in
#        2.c.3 will be over-written give the input for 'P_{II}^1' (defaut:
#        'special_iso' left blanck, code assumes general case described by four
#        parameters of 2.c.3)
special_iso =

# 1.g) For type 'external_Pk' (see external documentation external_Pk/README.md
#      for more details):
# 1.g.1) Command generating the table. If the table is already generated, just
#        write "cat <table_file>". The table should have two columns (k, pk) if
#        tensors are not requested, or three columns (k, pks, pkt) if they are.
#command = python external/external_Pk/generate_Pk_example.py
#command = python external/external_Pk/generate_Pk_example_w_tensors.py
command = cat external/external_Pk/Pk_example.dat
#command = cat external/external_Pk/Pk_example_w_tensors.dat

# 1.g.2) If the table is not pregenerated, parameters to be passed to the
#        command, in the right order, starting from "custom1" and up to
#        "custom10". They must be real numbers.
custom1 = 0.05     # In the example command: k_pivot
custom2 = 2.215e-9 # In the example command: A_s
custom3 = 0.9624   # In the example command: n_s
custom4 = 2e-10    # In the example (with tensors) command: A_t
custom5 = -0.1     # In the example (with tensors) command: n_t
#custom6 = 0
#custom7 = 0
#custom8 = 0
#custom9 = 0
#custom10 = 0




# ----------------------------------
# ----> Output parameters:
# ----------------------------------

# 1) Output for external files
# 1.a) File name root 'root' for all output files (if Cl requested, written to
#      '<root>cl.dat'; if P(k) requested, written to '<root>pk.dat'; plus
#      similar files for scalars, tensors, pairs of initial conditions, etc.;
#      if file with input parameters requested, written to
#      '<root>parameters.ini')
#      If no root is specified, the root will be set to 'output/<thisfilename>'
#      (default: output/<thisfilename>)
#root = output/test_

# 1.a.1) If root is specified, do you want to keep overwriting the file,
#      or do you want to create files numbered as '<root>N_'.
#      Can be set to anything starting with 'y' or 'n' (default: no)
overwrite_root = yes

# 1.b) Do you want headers at the beginning of each output file (giving
#      precisions on the output units/ format) ? Can be set to anything
#      starting with 'y' or 'n' (default: yes)
headers = yes

# 1.c) In all output files, do you want columns to be normalized and ordered
#      with the default CLASS definitions or with the CAMB definitions (often
#      idential to the CMBFAST one) ? Set 'format' to either 'class', 'CLASS',
#      'camb' or 'CAMB' (default: 'class')
format = class

# 1.d) Do you want to write a table of background quantitites in a file? This
#      will include H, densities, Omegas, various cosmological distances, sound
#      horizon, etc., as a function of conformal time, proper time, scale
#      factor. Can be set to anything starting with 'y' or 'no' (default: no)
write_background = yes

# 1.e) Do you want to write a table of thermodynamics quantitites in a file?
#      Can be set to anything starting with 'y' or 'n'. (default: no)
write_thermodynamics = no

# 1.f) Do you want to write a table of perturbations to files for certain
#      wavenumbers k? Dimension of k is 1/Mpc. The actual wave numbers are
#      chosen such that they are as close as possible to the requested k-values. (default: none)
#k_output_values = 0.01, 0.1, 0.0001

# 1.g) Do you want to write the primordial scalar(/tensor) spectrum in a file,
#      with columns k [1/Mpc], P_s(k) [dimensionless], ( P_t(k)
#      [dimensionless])? Can be set to anything starting with 'y' or 'n'. (default: no)
write_primordial = no

# 1.h) Do you want to write the exotic energy injection function in a file,
#     with columns z [dimensionless], dE/dz_inj, dE/dz_dep [J/(m^3 s)]?
# 1.i) Do you want to write also the non-injected photon heating?
#     File created if 'write_exotic_injection' or
#     'write_noninjection' set to something containing the letter
#     'y' or 'Y', file written, otherwise not written (default: no)
write_exotic_injection = no
#write_noninjection = no

# 1.k) Do you want to write the spectral distortions in a file,
#     with columns x [dimensionless], DI(x) [dimensionless]?
#     File created if 'write_distortions' set to something containing the letter
#     'y' or 'Y', file written, otherwise not written (default: no)
write_distortions = no

# 1.l) Do you want to have all input/precision parameters which have been read
#      written in file '<root>parameters.ini', and those not written in file
#      '<root>unused_parameters' ? Can be set to anything starting with 'y'
#      or 'n'. (default: yes)
write_parameters = yes

# 1.m) Do you want a warning written in the standard output when an input
#      parameter or value could not be interpreted ? Can be set to anything starting
#      with 'y' or 'n' (default: no)
write_warnings = no

# 2) Amount of information sent to standard output: Increase integer values
#    to make each module more talkative (default: all set to 0)
input_verbose = 3
background_verbose = 3
thermodynamics_verbose = 3
perturbations_verbose = 4
transfer_verbose = 1
primordial_verbose = 1
harmonic_verbose = 1
fourier_verbose = 1
lensing_verbose = 1
distortions_verbose = 1
output_verbose = 1
